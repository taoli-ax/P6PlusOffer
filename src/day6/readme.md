# Design pattern
### 策略模式，解决共同协作的实践


### 适配器模式
老师：
我曾经遇到。。。。。这个系统的customerId那个系统UserId.程序员如果来个if else判断，中间来个变量赋值。。。很容易有bug。。。
我的经历；
之前给yqn做数据清洗的时候，面临相同的困境，很多field在不同version的系统中有变化，我当时非常困难，每次都读不懂自己的代码，要头脑风暴一下或者debug运行代码，
花很久的时间做重复的事情，甚为难堪无奈。。。。

```txt
如果我当时懂得适配器模式设计一下我的代码，或者谁来review一下我的代码，哎，谁说经师易求，过了3年了
```

第三方集成服务，不应该侵入到你的代码中，尤其当第三方变化时，硬编码会影响到你的场景代码

`间接是程序员解决结构问题的钥匙`

- Abstract类用参数控制种类好不好？
    - 不好，底层不应该主动感知上层使用场景的变化，避免成为公共的component
老师：程序员要知道编写的代码时的定位
    - 向场景负责，国内的电商大厂都是应用型的
    - 向公共能力负责
###### 适配器的委托
- 进一步解耦，将场景和底层隔离
- 接口规约

老师：
- 适配器模式实现的套路： 抽象子类继承底层（基类或接口），用抽象方法将适配层所需的场景参数，类似一个探针，探知外部场景情况，委托实现进一步解耦
- 削峰填谷如何适配不同场景的？用适配器模式适配不同的场景
- 做一套系统是否能开放给其他系统，互联网思想

## 工厂模式
### 简单工厂
不关心如何制造product，只获取结果
实际生产中，有很多的工厂，决策什么工厂是架构实现的要点，工厂可配置--> 配置化+场景参数-->灵活配置工厂


工厂模式+接口规约
  - 接口方法消费直接的场景参数
  - 接口工厂方法通过委托，适配等待设计模式，综合运用尾调用方法提供不同的子对象

架构的扩展思想：
- 从第1行一步到位：避免一个系统随着需求迭代产生多套架构同时存在的问题
- 再小的体量也要从架构的角度去实现，一个功能要深入到架构

### 抽象工厂
架构的收口：定义架构边界
  - 方法：顶层接口 定义能力的边界 ， 基类（抽象类）架构的边界
  - 实际意义：问题的范围，领域模型的范围

架构的收口，规定了微服务的边界，超过边界就是新的微服务子应用了

听说你看过源码？
- 介绍的时候，先从确定源码的边界开始，再看继承关系看出设计模式，再介绍继承关系覆盖使用场景，这样说起来就清晰了

工厂模式的好处：
- 集中申请内存，降低了内存使用量
- 屏蔽底层改动对上层的冲击

工厂方法的使用场景
- 创建对象需求多
- 创建复杂对象
- 创建过程升级迭代频繁

工厂方法的缺点
- 冗余代码增长，如何权衡呢？
  - 如果未知因素太多，冗余的代码也是可以接受的，但如果可见的历史区间内变化不会产生，就不要搞冗余


### HOMEWORK
1. interface和abstract的优劣对比，怎么选择？ 
  - what: 都是java中实现了继承能力的方式
  - why :interface不含实现，但是可以实现多继承，abstract 包含实现，但是单继承关系直接，不够灵活
  - how:如果需要降低耦合，让不同的系统能够遵循相同的contact，就用interface
2. 理论上abstract class和interface是可以互相交换的.如果适配不同的应用场景呢？
  - 如果要实现代码共享，用abstract
  - 如果要实现多继承，或者共同遵循一套规则，降低不同服务直接的耦合，用interface
3. 什么是能感知业务的类
  - 适配器模式下的抽象类将目标底层和场景层隔离，只开放感知外部场景参数的方法，降低场景和底层的耦合，无需关心底层的实现
4. 怎么理解底层不应该主动告知上层的场景使用，无论是设备类型还是App类型，这个变化都不应该穿透到底层这句话？
  - 底层的实现逻辑是独立的，不受到业务场景的参数变化，无论上层场景如何变化，底层不受冲击